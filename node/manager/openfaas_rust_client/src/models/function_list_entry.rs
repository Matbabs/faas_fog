/* 
 * OpenFaaS API Gateway
 *
 * OpenFaaS API documentation
 *
 * OpenAPI spec version: 0.8.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct FunctionListEntry {
  /// The name of the function
  #[serde(rename = "name")]
  name: String,
  /// The fully qualified docker image name of the function
  #[serde(rename = "image")]
  image: String,
  /// The amount of invocations for the specified function
  #[serde(rename = "invocationCount")]
  invocation_count: f32,
  /// The current minimal ammount of replicas
  #[serde(rename = "replicas")]
  replicas: f32,
  /// The current available amount of replicas
  #[serde(rename = "availableReplicas")]
  available_replicas: f32,
  /// Process for watchdog to fork
  #[serde(rename = "envProcess")]
  env_process: String,
  /// A map of labels for making scheduling or routing decisions
  #[serde(rename = "labels")]
  labels: ::std::collections::HashMap<String, String>,
  /// A map of annotations for management, orchestration, events and build tasks
  #[serde(rename = "annotations")]
  annotations: Option<::std::collections::HashMap<String, String>>
}

impl FunctionListEntry {
  pub fn new(name: String, image: String, invocation_count: f32, replicas: f32, available_replicas: f32, env_process: String, labels: ::std::collections::HashMap<String, String>) -> FunctionListEntry {
    FunctionListEntry {
      name: name,
      image: image,
      invocation_count: invocation_count,
      replicas: replicas,
      available_replicas: available_replicas,
      env_process: env_process,
      labels: labels,
      annotations: None
    }
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> FunctionListEntry {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_image(&mut self, image: String) {
    self.image = image;
  }

  pub fn with_image(mut self, image: String) -> FunctionListEntry {
    self.image = image;
    self
  }

  pub fn image(&self) -> &String {
    &self.image
  }


  pub fn set_invocation_count(&mut self, invocation_count: f32) {
    self.invocation_count = invocation_count;
  }

  pub fn with_invocation_count(mut self, invocation_count: f32) -> FunctionListEntry {
    self.invocation_count = invocation_count;
    self
  }

  pub fn invocation_count(&self) -> &f32 {
    &self.invocation_count
  }


  pub fn set_replicas(&mut self, replicas: f32) {
    self.replicas = replicas;
  }

  pub fn with_replicas(mut self, replicas: f32) -> FunctionListEntry {
    self.replicas = replicas;
    self
  }

  pub fn replicas(&self) -> &f32 {
    &self.replicas
  }


  pub fn set_available_replicas(&mut self, available_replicas: f32) {
    self.available_replicas = available_replicas;
  }

  pub fn with_available_replicas(mut self, available_replicas: f32) -> FunctionListEntry {
    self.available_replicas = available_replicas;
    self
  }

  pub fn available_replicas(&self) -> &f32 {
    &self.available_replicas
  }


  pub fn set_env_process(&mut self, env_process: String) {
    self.env_process = env_process;
  }

  pub fn with_env_process(mut self, env_process: String) -> FunctionListEntry {
    self.env_process = env_process;
    self
  }

  pub fn env_process(&self) -> &String {
    &self.env_process
  }


  pub fn set_labels(&mut self, labels: ::std::collections::HashMap<String, String>) {
    self.labels = labels;
  }

  pub fn with_labels(mut self, labels: ::std::collections::HashMap<String, String>) -> FunctionListEntry {
    self.labels = labels;
    self
  }

  pub fn labels(&self) -> &::std::collections::HashMap<String, String> {
    &self.labels
  }


  pub fn set_annotations(&mut self, annotations: ::std::collections::HashMap<String, String>) {
    self.annotations = Some(annotations);
  }

  pub fn with_annotations(mut self, annotations: ::std::collections::HashMap<String, String>) -> FunctionListEntry {
    self.annotations = Some(annotations);
    self
  }

  pub fn annotations(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.annotations.as_ref()
  }

  pub fn reset_annotations(&mut self) {
    self.annotations = None;
  }

}



