/* 
 * OpenFaaS API Gateway
 *
 * OpenFaaS API documentation
 *
 * OpenAPI spec version: 0.8.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct FunctionDefinition {
  /// Name of deployed function
  #[serde(rename = "service")]
  service: String,
  /// Network, usually func_functions for Swarm (deprecated)
  #[serde(rename = "network")]
  network: Option<String>,
  /// Docker image in accessible registry
  #[serde(rename = "image")]
  image: String,
  /// Process for watchdog to fork
  #[serde(rename = "envProcess")]
  env_process: String,
  /// Overrides to environmental variables
  #[serde(rename = "envVars")]
  env_vars: Option<::std::collections::HashMap<String, String>>,
  #[serde(rename = "constraints")]
  constraints: Option<Vec<String>>,
  /// A map of labels for making scheduling or routing decisions
  #[serde(rename = "labels")]
  labels: Option<::std::collections::HashMap<String, String>>,
  /// A map of annotations for management, orchestration, events and build tasks
  #[serde(rename = "annotations")]
  annotations: Option<::std::collections::HashMap<String, String>>,
  #[serde(rename = "secrets")]
  secrets: Option<Vec<String>>,
  /// Private registry base64-encoded basic auth (as present in ~/.docker/config.json)
  #[serde(rename = "registryAuth")]
  registry_auth: Option<String>,
  #[serde(rename = "limits")]
  limits: Option<Value>,
  #[serde(rename = "requests")]
  requests: Option<Value>,
  /// Make the root filesystem of the function read-only
  #[serde(rename = "readOnlyRootFilesystem")]
  read_only_root_filesystem: Option<bool>
}

impl FunctionDefinition {
  pub fn new(service: String, image: String, env_process: String) -> FunctionDefinition {
    FunctionDefinition {
      service: service,
      network: None,
      image: image,
      env_process: env_process,
      env_vars: None,
      constraints: None,
      labels: None,
      annotations: None,
      secrets: None,
      registry_auth: None,
      limits: None,
      requests: None,
      read_only_root_filesystem: None
    }
  }

  pub fn set_service(&mut self, service: String) {
    self.service = service;
  }

  pub fn with_service(mut self, service: String) -> FunctionDefinition {
    self.service = service;
    self
  }

  pub fn service(&self) -> &String {
    &self.service
  }


  pub fn set_network(&mut self, network: String) {
    self.network = Some(network);
  }

  pub fn with_network(mut self, network: String) -> FunctionDefinition {
    self.network = Some(network);
    self
  }

  pub fn network(&self) -> Option<&String> {
    self.network.as_ref()
  }

  pub fn reset_network(&mut self) {
    self.network = None;
  }

  pub fn set_image(&mut self, image: String) {
    self.image = image;
  }

  pub fn with_image(mut self, image: String) -> FunctionDefinition {
    self.image = image;
    self
  }

  pub fn image(&self) -> &String {
    &self.image
  }


  pub fn set_env_process(&mut self, env_process: String) {
    self.env_process = env_process;
  }

  pub fn with_env_process(mut self, env_process: String) -> FunctionDefinition {
    self.env_process = env_process;
    self
  }

  pub fn env_process(&self) -> &String {
    &self.env_process
  }


  pub fn set_env_vars(&mut self, env_vars: ::std::collections::HashMap<String, String>) {
    self.env_vars = Some(env_vars);
  }

  pub fn with_env_vars(mut self, env_vars: ::std::collections::HashMap<String, String>) -> FunctionDefinition {
    self.env_vars = Some(env_vars);
    self
  }

  pub fn env_vars(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.env_vars.as_ref()
  }

  pub fn reset_env_vars(&mut self) {
    self.env_vars = None;
  }

  pub fn set_constraints(&mut self, constraints: Vec<String>) {
    self.constraints = Some(constraints);
  }

  pub fn with_constraints(mut self, constraints: Vec<String>) -> FunctionDefinition {
    self.constraints = Some(constraints);
    self
  }

  pub fn constraints(&self) -> Option<&Vec<String>> {
    self.constraints.as_ref()
  }

  pub fn reset_constraints(&mut self) {
    self.constraints = None;
  }

  pub fn set_labels(&mut self, labels: ::std::collections::HashMap<String, String>) {
    self.labels = Some(labels);
  }

  pub fn with_labels(mut self, labels: ::std::collections::HashMap<String, String>) -> FunctionDefinition {
    self.labels = Some(labels);
    self
  }

  pub fn labels(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.labels.as_ref()
  }

  pub fn reset_labels(&mut self) {
    self.labels = None;
  }

  pub fn set_annotations(&mut self, annotations: ::std::collections::HashMap<String, String>) {
    self.annotations = Some(annotations);
  }

  pub fn with_annotations(mut self, annotations: ::std::collections::HashMap<String, String>) -> FunctionDefinition {
    self.annotations = Some(annotations);
    self
  }

  pub fn annotations(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.annotations.as_ref()
  }

  pub fn reset_annotations(&mut self) {
    self.annotations = None;
  }

  pub fn set_secrets(&mut self, secrets: Vec<String>) {
    self.secrets = Some(secrets);
  }

  pub fn with_secrets(mut self, secrets: Vec<String>) -> FunctionDefinition {
    self.secrets = Some(secrets);
    self
  }

  pub fn secrets(&self) -> Option<&Vec<String>> {
    self.secrets.as_ref()
  }

  pub fn reset_secrets(&mut self) {
    self.secrets = None;
  }

  pub fn set_registry_auth(&mut self, registry_auth: String) {
    self.registry_auth = Some(registry_auth);
  }

  pub fn with_registry_auth(mut self, registry_auth: String) -> FunctionDefinition {
    self.registry_auth = Some(registry_auth);
    self
  }

  pub fn registry_auth(&self) -> Option<&String> {
    self.registry_auth.as_ref()
  }

  pub fn reset_registry_auth(&mut self) {
    self.registry_auth = None;
  }

  pub fn set_limits(&mut self, limits: Value) {
    self.limits = Some(limits);
  }

  pub fn with_limits(mut self, limits: Value) -> FunctionDefinition {
    self.limits = Some(limits);
    self
  }

  pub fn limits(&self) -> Option<&Value> {
    self.limits.as_ref()
  }

  pub fn reset_limits(&mut self) {
    self.limits = None;
  }

  pub fn set_requests(&mut self, requests: Value) {
    self.requests = Some(requests);
  }

  pub fn with_requests(mut self, requests: Value) -> FunctionDefinition {
    self.requests = Some(requests);
    self
  }

  pub fn requests(&self) -> Option<&Value> {
    self.requests.as_ref()
  }

  pub fn reset_requests(&mut self) {
    self.requests = None;
  }

  pub fn set_read_only_root_filesystem(&mut self, read_only_root_filesystem: bool) {
    self.read_only_root_filesystem = Some(read_only_root_filesystem);
  }

  pub fn with_read_only_root_filesystem(mut self, read_only_root_filesystem: bool) -> FunctionDefinition {
    self.read_only_root_filesystem = Some(read_only_root_filesystem);
    self
  }

  pub fn read_only_root_filesystem(&self) -> Option<&bool> {
    self.read_only_root_filesystem.as_ref()
  }

  pub fn reset_read_only_root_filesystem(&mut self) {
    self.read_only_root_filesystem = None;
  }

}



